@using AirCode.Utilities.DataStructures
@using AirCode.Utilities.HelperScripts
@using AirCode.Services.Cryptography
@using Microsoft.AspNetCore.Components
@using AirCode.Models.QRCode
@using AirCode.Components.SharedPrefabs.Spinner
@inject IJSRuntime JS
@inject ICryptographyService CryptographyService

<div class="qr-code">
    <h3>Attendance QR Code</h3>
    <div class="qr-code-container @(IsLoading ? "loading" : "")">
        @if (IsLoading)
        {
            <div class="qr-loading-overlay">
                <div class="qr-loading-spinner"></div>
                <p class="qr-loading-text">@LoadingMessage</p>
            </div>
        }
        <div id="qrCodeContainer_@QRCodeId" class="@(IsLoading ? "hidden" : "")"></div>
    </div>
    <div class="qr-code-info">
        <p>Scan this QR code to mark attendance</p>
        <p>Valid for @Duration minutes</p>
        @if (!string.IsNullOrEmpty(CourseCode))
        {
            <p><strong>Course:</strong> @CourseCode</p>
        }
        @if (UseTemporalKeyRefresh)
        {
            <p><small>üîÑ Security keys refresh automatically</small></p>
        }
        @if (AllowOfflineSync)
        {
            <p><small>üì± Offline scanning supported</small></p>
        }
        @if (IsLoading && UseTemporalKeyRefresh)
        {
            <p class="loading-status"><small>‚è≥ Refreshing security keys...</small></p>
        }
    </div>
</div>

@code {
    [Parameter] public string SessionId { get; set; }
    [Parameter] public string CourseCode { get; set; }
    [Parameter] public DateTime StartTime { get; set; } = DateTime.UtcNow;
    [Parameter] public int Duration { get; set; } = 30;
    [Parameter] public QRCodeTheme Theme { get; set; } = QRCodeTheme.Standard;
    [Parameter] public QRCodeBaseOptions Options { get; set; }
    [Parameter] public EventCallback<QRCodeData> OnGenerated { get; set; }
    
    // New security and sync parameters
    [Parameter] public bool UseTemporalKeyRefresh { get; set; } = false;
    [Parameter] public bool AllowOfflineSync { get; set; } = true;
    [Parameter] public AdvancedSecurityFeatures SecurityFeatures { get; set; } = AdvancedSecurityFeatures.Default;
    [Parameter] public string TemporalKey { get; set; } = string.Empty;
    
    // External payload parameter - when provided, skip internal encoding
    [Parameter] public string ExternalPayload { get; set; }
    
    private string QRCodeId = Guid.NewGuid().ToString("N");
    private IJSObjectReference _qrCodeModule;
    private bool _jsInitialized = false;
    private QRCodeData _generatedQRCode;
    private QRCodeDecoder _qrDecoder;
    
    // Previous state tracking to prevent infinite loops
    private string _lastGeneratedPayload = string.Empty;
    private string _lastTemporalKey = string.Empty;
    private string _lastContentIdentifier = string.Empty;
    private bool _isGenerating = false; // Critical: Prevent concurrent generation
    
    // Loading state management
    private bool IsLoading = false;
    private string LoadingMessage = "Generating QR Code...";
    
    // Cancellation support for async operations
    private CancellationTokenSource _cancellationTokenSource = new();
    
    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        _qrDecoder = new QRCodeDecoder(CryptographyService);
        
        if (!_jsInitialized)
        {
            try
            {
                _qrCodeModule = await JS.InvokeAsync<IJSObjectReference>("import", "./js/qrCodeModule.js");
                _jsInitialized = true;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to load JS module: {ex.Message}");
            }
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // Validate required parameters
        if (string.IsNullOrEmpty(SessionId))
        {
            SessionId = Guid.NewGuid().ToString("N");
        }

        if (string.IsNullOrEmpty(CourseCode))
        {
            throw new ArgumentException("CourseCode is required for QR code generation");
        }

        // Initialize default options if not provided
        Options ??= new QRCodeBaseOptions
        {
            Size = 300,
            DarkColor = "#000000",
            LightColor = "#FFFFFF",
            ErrorLevel = ErrorCorrectionLevel.M,
            Margin = 4
        };
        
        await base.OnParametersSetAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Only generate on first render or when explicitly needed
        if (firstRender && _jsInitialized)
        {
            await GenerateSecureQRCode();
        }
        // Remove automatic regeneration logic from OnAfterRenderAsync to prevent infinite loops
    }

    // Public method that can be called externally when regeneration is needed
    public async Task TriggerRegeneration()
    {
        if (_jsInitialized && !string.IsNullOrEmpty(CourseCode) && ShouldRegenerateQRCode())
        {
            // Check if temporal key changed to show appropriate loading message
            if (UseTemporalKeyRefresh && TemporalKey != _lastTemporalKey)
            {
                LoadingMessage = "Refreshing security keys...";
            }
            else
            {
                LoadingMessage = "Updating QR Code...";
            }
            
            await GenerateSecureQRCode();
        }
    }

    private bool ShouldRegenerateQRCode()
    {
        // Prevent regeneration if already generating
        if (_isGenerating) return false;
        
        var currentIdentifier = GetCurrentContentIdentifier();
        
        // Check if content actually changed
        if (currentIdentifier == _lastContentIdentifier)
        {
            return false;
        }
        
        // Check if we have an external payload and it's different from last generated
        if (!string.IsNullOrEmpty(ExternalPayload))
        {
            return ExternalPayload != _lastGeneratedPayload;
        }
        
        // Check if temporal key changed
        if (UseTemporalKeyRefresh && TemporalKey != _lastTemporalKey)
        {
            return true;
        }
        
        return true;
    }

    private string GetCurrentContentIdentifier()
    {
        // Use external payload if provided, otherwise generate identifier
        if (!string.IsNullOrEmpty(ExternalPayload))
        {
            return ExternalPayload;
        }
        
        return $"{SessionId}|{CourseCode}|{StartTime:O}|{Duration}|{UseTemporalKeyRefresh}|{AllowOfflineSync}|{SecurityFeatures}|{TemporalKey}";
    }

    private async Task GenerateSecureQRCode()
    {
        // Prevent concurrent generation
        if (_isGenerating)
        {
            return;
        }

        try
        {
            _isGenerating = true;
            
            if (!_jsInitialized || string.IsNullOrEmpty(CourseCode))
                return;

            // Show loading state without triggering StateHasChanged in a loop
            var wasLoading = IsLoading;
            IsLoading = true;
            
            // Only call StateHasChanged if state actually changed
            if (!wasLoading)
            {
                StateHasChanged();
            }
            
            // Small delay to ensure loading state is visible
            await Task.Delay(100, _cancellationTokenSource.Token);

            string secureContent;
            
            // Use external payload if provided, otherwise generate internally
            if (!string.IsNullOrEmpty(ExternalPayload))
            {
                secureContent = ExternalPayload;
                _lastGeneratedPayload = ExternalPayload;
            }
            else
            {
                // Generate encrypted QR code content using the decoder service
                secureContent = await _qrDecoder.EncodeSessionDataAsync(
                    SessionId,
                    CourseCode,
                    StartTime,
                    Duration,
                    AllowOfflineSync,
                    UseTemporalKeyRefresh,
                    SecurityFeatures,
                    TemporalKey
                );
                _lastGeneratedPayload = secureContent;
                _lastTemporalKey = TemporalKey; // Update the last temporal key
            }

            // Update content identifier to prevent unnecessary regeneration
            _lastContentIdentifier = GetCurrentContentIdentifier();

            // Set content for options
            var updatedOptions = Options with { Content = secureContent };
            
            string svg;
            int size = updatedOptions.Size;
            
            // Generate QR code based on theme
            switch (Theme)
            {
                case QRCodeTheme.Gradient:
                    svg = await GenerateGradientQRCode(secureContent, size, updatedOptions);
                    break;
                
                case QRCodeTheme.Branded:
                    svg = await GenerateBrandedQRCode(secureContent, size, updatedOptions);
                    break;
                
                case QRCodeTheme.GradientWithLogo:
                    svg = await GenerateGradientBrandedQRCode(secureContent, size, updatedOptions);
                    break;
                
                default: // Standard theme
                    svg = await GenerateStandardQRCode(secureContent, size, updatedOptions);
                    break;
            }
            
            if (!string.IsNullOrEmpty(svg))
            {
                await _qrCodeModule.InvokeVoidAsync("setSvgContent", $"qrCodeContainer_{QRCodeId}", svg);
                
                // Create QR code data object
                _generatedQRCode = new QRCodeData
                {
                    Id = QRCodeId,
                    Content = _lastContentIdentifier,
                    SvgContent = svg,
                    CreatedAt = DateTime.UtcNow,
                    ValidDuration = Duration,
                    Theme = Theme
                };
                
                // Invoke callback if registered
                if (OnGenerated.HasDelegate)
                {
                    await OnGenerated.InvokeAsync(_generatedQRCode);
                }
            }
        }
        catch (OperationCanceledException)
        {
            // Operation was cancelled, this is expected during disposal
            Console.WriteLine("QR code generation was cancelled");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error generating secure QR code: {ex.Message}");
        }
        finally
        {
            // Hide loading state and mark generation as complete
            IsLoading = false;
            _isGenerating = false;
            
            // Only call StateHasChanged if we're not disposed
            if (!_cancellationTokenSource.Token.IsCancellationRequested)
            {
                StateHasChanged();
            }
        }
    }

    private async Task<string> GenerateStandardQRCode(string content, int size, QRCodeBaseOptions options)
    {
        var jsOptions = new
        {
            errorLevel = options.ErrorLevel.ToString(),
            margin = options.Margin
        };
        
        return await _qrCodeModule.InvokeAsync<string>("generateQrCode", 
            content, size, options.DarkColor, options.LightColor, jsOptions);
    }

    private async Task<string> GenerateGradientQRCode(string content, int size, QRCodeBaseOptions baseOptions)
    {
        var gradientOptions = baseOptions as QRCodeGradientOptions ?? new QRCodeGradientOptions 
        { 
            Content = content,
            Size = size,
            DarkColor = baseOptions.DarkColor,
            LightColor = baseOptions.LightColor,
            ErrorLevel = baseOptions.ErrorLevel,
            Margin = baseOptions.Margin
        };
        
        var jsOptions = new
        {
            errorLevel = gradientOptions.ErrorLevel.ToString(),
            useGradient = true,
            gradientDirection = GradientDirectionToString(gradientOptions.Direction),
            gradientColor1 = gradientOptions.GradientColor1,
            gradientColor2 = gradientOptions.GradientColor2,
            margin = gradientOptions.Margin
        };
        
        return await _qrCodeModule.InvokeAsync<string>("generateEnhancedQrCode", 
            content, size, gradientOptions.DarkColor, gradientOptions.LightColor, jsOptions);
    }

    private async Task<string> GenerateBrandedQRCode(string content, int size, QRCodeBaseOptions baseOptions)
    {
        var brandedOptions = baseOptions as QRCodeBrandedOptions ?? new QRCodeBrandedOptions 
        { 
            Content = content,
            Size = size,
            LogoUrl = "/icon-192.png",
            DarkColor = baseOptions.DarkColor,
            LightColor = baseOptions.LightColor,
            ErrorLevel = baseOptions.ErrorLevel,
            Margin = baseOptions.Margin
        };
        
        var jsOptions = new
        {
            errorLevel = brandedOptions.ErrorLevel.ToString(),
            logoUrl = brandedOptions.LogoUrl,
            logoSizeRatio = brandedOptions.LogoSizeRatio,
            addLogoBorder = brandedOptions.AddLogoBorder,
            logoBorderColor = brandedOptions.LogoBorderColor,
            logoBorderWidth = brandedOptions.LogoBorderWidth,
            logoBorderRadius = brandedOptions.LogoBorderRadius,
            margin = brandedOptions.Margin
        };
        
        return await _qrCodeModule.InvokeAsync<string>("generateEnhancedQrCode", 
            content, size, brandedOptions.DarkColor, brandedOptions.LightColor, jsOptions);
    }

    private async Task<string> GenerateGradientBrandedQRCode(string content, int size, QRCodeBaseOptions baseOptions)
    {
        var combinedOptions = baseOptions as QRCodeGradientBrandedOptions ?? new QRCodeGradientBrandedOptions 
        { 
            Content = content,
            Size = size,
            LogoUrl = "/icon-192.png",
            DarkColor = baseOptions.DarkColor,
            LightColor = baseOptions.LightColor,
            ErrorLevel = baseOptions.ErrorLevel,
            Margin = baseOptions.Margin
        };
        
        var jsOptions = new
        {
            errorLevel = combinedOptions.ErrorLevel.ToString(),
            useGradient = true,
            gradientDirection = GradientDirectionToString(combinedOptions.Direction),
            gradientColor1 = combinedOptions.GradientColor1,
            gradientColor2 = combinedOptions.GradientColor2,
            logoUrl = combinedOptions.LogoUrl,
            logoSizeRatio = combinedOptions.LogoSizeRatio,
            addLogoBorder = combinedOptions.AddLogoBorder,
            logoBorderColor = combinedOptions.LogoBorderColor,
            logoBorderWidth = combinedOptions.LogoBorderWidth,
            logoBorderRadius = combinedOptions.LogoBorderRadius,
            margin = combinedOptions.Margin
        };
        
        return await _qrCodeModule.InvokeAsync<string>("generateEnhancedQrCode", 
            content, size, combinedOptions.DarkColor, combinedOptions.LightColor, jsOptions);
    }
    
    private string GradientDirectionToString(GradientDirection direction)
    {
        return direction switch
        {
            GradientDirection.LinearX => "linear-x",
            GradientDirection.LinearY => "linear-y",
            GradientDirection.Diagonal => "diagonal",
            GradientDirection.Radial => "radial",
            _ => "linear-x"
        };
    }
    
    // Public method to force QR code regeneration (can be called externally)
    public async Task RefreshQRCode()
    {
        LoadingMessage = "Refreshing QR Code...";
        await GenerateSecureQRCode();
    }
    
    // Public method to refresh with temporal key update
    public async Task RefreshWithTemporalKey(string newTemporalKey)
    {
        LoadingMessage = "Refreshing security keys...";
        TemporalKey = newTemporalKey;
        await GenerateSecureQRCode();
    }
    
    public async ValueTask DisposeAsync()
    {
        try
        {
            // Cancel any ongoing operations
            _cancellationTokenSource?.Cancel();
            
            // Dispose of the JS module
            if (_qrCodeModule != null)
            {
                await _qrCodeModule.DisposeAsync();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error disposing JS module: {ex.Message}");
        }
        finally
        {
            _cancellationTokenSource?.Dispose();
        }
    }
}
